# 최소 개수 못박기 (pinning)

n = int(input())

# 각 막대의 시작점과 끝점을 저장할 리스트를 생성
L = []

for _ in range(n):
	a, b = map(int, input().split())		# a = 시작점, b = 끝점
	L.append([a, b])
	
L.sort(key=lambda x : [x[1], x[0]])		# 막대를 끝점 순으로 정렬하되, 끝점이 같다면 시작점 순으로 정렬 
S = []	# 시작점 리스트
F = []	# 끝점 리스트

for i in range(n):
	S.append(L[i][0])
	F.append(L[i][1])

k = L[0][1] 	# 막대의 끝점을 저장
cnt = 1

for i in range(1, n):
	if k < S[i]:
		cnt += 1
		k = F[i]
print(cnt)

'''
1. 알고리즘 설명
모든 막대를 박을 수 있는 최소의 못의 개수를 구할때, 막대의 끝점에만 못이 박히더라도 최소 개수의 못을 사용할 수 있다.
막대가 끝나는 끝점을 기준으로 오름차순 정렬하고 다음 막대의 시작점이 이전 막대의 끝점보다 늦다면 못을 꽂는다. 그리고 이 때의 마지막 끝점을 k에 저장한다.
이런 방식으로 모든 막대를 탐색하며 못을 꽂으면 최소의 못으로 많은 수의 막대를 꽂을 수 있다.

1) 막대의 끝점(b)을 기준으로 오름차순 정렬 한다. 이 때 끝점이 같다면 시작점(a)을 기준으로 오름차순 정렬한다.
2) 시작점(a)과 끝점(b)을 정렬한 순서대로 각각 S, F에 삽입한다.
3) 현재 막대의 끝점(k) 보다 큰 시작점(S[i])을 가진 막대가 등장하면 새로운 못이 필요하므로 cnt를 1 증가시키고, k = F[i]로 업데이트한다.
4) i < n 일 동안 반복한다.

2. 수행시간 분석
막대 개수, 시작점, 끝점 등의 입력: O(n)
막대 정렬하기: 일반적으로 퀵소트, 병합정렬 등을 사용하면 O(nlogn)
반복하며 수행하는 부분의 수행시간은 모두 O(n)이므로 전체 시간 복잡도는 O(nlogn)이다.
'''
